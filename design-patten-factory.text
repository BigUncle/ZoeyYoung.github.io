Title: [设计模式] 《Head First 设计模式》笔记之工厂模式
Date: 2012-06-13
Tags: 读书,Book
Slug: design-patten-factory
Author: Zoey Young
Summary: 《Head First 设计模式》笔记之工厂模式

工厂模式

——烘烤OO的精华

关键——"松耦合"

**实例化**这个活动不应该总是公开地进行

初始化经常造成**"耦合"**问题

有一些要实例化的具体类, 究竟实例化哪个类, 要在运行时由一些条件来决定, 一有变化或扩展, 必须重新打开这段代码进行检查和修改. 这部分就是代码中**变化的**部分, 因此要考虑把它们从**不变的**部分分离出来.

针对接口编程, 可以隔离掉以后系统可能发生的一大堆改变.

设计原则: 对扩展开放, 对修改关闭.

找出会变化的方面, 把它们从不变的部分分离出来.

将创建对象的代码从普通方法中抽离, 放入另一个对象(工厂)中, 这个新对象只管如何创建具体对象.

工厂(factory)处理创建对象的细节.

所有的工厂都是用来封装对象的创建.

一开始的疑问:

单独出来有什么好处, 有变化时还是得修改工厂对象.

没考虑到的情况是: **可能还有其它地方会利用这个工厂来创建对象,, 这个工厂可以有许多客户. 因此, 当以后实现改变时, 只需修改这个类, 而不会导致所有创建相关对象的地方都要修改.**

将创建对象的代码集中在一个对象或方法中, 可以避免代码中的重复, 并且更方便以后的维护. 这也意味着客户在实例化对象时, 只会依赖于接口, 而不是具体类.

设计原则: 针对接口编程, 而不是针对实现编程.

**我的理解**: 在我们系统中的很多地方可能都需要用到相同的一段代码——这段代码用来创建对象, 返回的对象的类型是一些具体类型的**抽象类型**, 创建的对象的**具体类型**在运行时才能确定, 这段代码应该略复杂, 可能会有许多if...else语句, 并且当系统需求变化, 比如加入新的具体类型时, 这段代码就需要修改——这里应该很自然想到代码复用, 如果没有把这段代码提取出来, 当系统需求变化的时候, 许多地方都要同时修改, 这时候利用工厂就理所当然了. 另外一种理解就是, 既然有很多地方都要以相同的方式创建产品, 那把这些代码在一处管理总比到处都要管理来得强, 虽然你仍然需要实例化真正的对象(而不是抽象对象).

把工厂定义成静态方法的缺点: 不能通过继承来改变创建方法的行为.

简单工厂其实不是一个设计模式, 反而比较像是一种编程习惯.

简单工厂由一个对象负责所有具体类的实例化(把全部的事情，在一个地方都处理完了), 任务太重.

### 工厂方法模式

定义: 工厂方法模式定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.

工厂方法用来处理对象的创建, 并将这样的行为封装在**子类**中. 这样, 客户程序中关于超类的代码就和子类对象创建代码解耦了.

工厂方法是抽象的, 依赖子类来处理对象的创建.

    abstract Product factoryMethod([String type]);

我的理解: 所有的产品都属于一个抽象产品类型A, 存在多个具体工厂的原因可能是可以对这些产品进行分类, 比如说有产品A1、A2、A3、A4、A5、A6都是A的子类, A1、A2、A3属于组1, A4、A5、A6属于组2, 具体工厂1生产组1, 具体工厂2生产组2, 工厂1只知道怎么生产组1的产品, 工厂2只知道怎么生产组2的产品, 这样就把产品的创建分配给多个子类了, 解决了简单工厂模式任务太重的缺点. 具体应用时要知道你要使用哪个具体工厂.

还有一个“抽象的”(这里说抽象的原因应该是它可能或大多数情况下会被继承, 但并不意味着一定是个抽象类)创建者类, 包含抽象工厂方法, 它实现了所有操纵产品的方法, 但不实现工厂方法(也可以定义一个默认的工厂方法来产生某些具体的产品, 这么一来, 即使创建者没有任何子类, 依然可以创建产品).

相似的原则——依赖倒置原则: 要依赖抽象, 不要依赖具体类.

不能让高层组件依赖低层组件, 而且, 不管高层或低层组件, "两者"都应该依赖于抽象.

我的理解: 上面的"抽象"工厂(高级组件), 不应该直接创建具体的产品(低层组件), 而应该只拥有抽象的产品(Product), 具体的产品由工厂方法创建, 高层组件并不关心具体生产出来的是什么产品, 因此它是依赖抽象的, 而低层组件只知道自己是抽象的产品的子类, 因此低层组件也只依赖于抽象.

倒置在哪?

本来高层组件依赖低层组件(许多箭头从上而下), 现在高层组件和低层组件都依赖同一个抽象, 这个抽象对于低层组件来说是高层的(箭头从下而上), 此时, 高层组件只有一条从上而下指向抽象的箭头.

倒置思考方式

一般: 先考虑高层, 然后考虑低层

倒置后: 先考虑有许多低层组件, 然后抽象出一个接口, 而高层组件只需依赖这个抽象, 而不管低层组件怎样.

指导方针(尽量, 而不是一定要遵循):

* 变量不可以持有具体类的引用

    如果使用new, 就会持有具体类的引用. 可以改用工厂来避开这样的做法.(这里的一个原因是类一般都是可变的, 用工厂可封装改变, 特例: 字符串不可变)

* 不要让类派生自具体类。

    如果派生自具体类, 就会依赖具体类. 应该派生自一个抽象(接口或抽象类).

* 不要覆盖基类中已实现的方法.

    基类中已实现的方法, 应该由所有的子类共享。

### 抽象工厂模式 Abstract Factory

对象创建型模式

创建产品家族

定义: 抽象工厂模式提供一个接口, 用于创建相关或相互依赖对象的家族, 而不需要明确指定具体类.

抽象工厂的方法经常以工厂方法的方式实现. 抽象工厂的任务是定义一个负责创建一组产品的接口. 这个接口内的每个方法都负责创建一个具体产品, 同时我们利用实现抽象工厂的子类来提供这些具体的做法. 所以, 在抽象工厂中利用工厂方法实现生产方法是相当自然的做法.

工厂方法和抽象工厂区别

工厂方法使用的是类, 而抽象工厂使用的是对象.

都负责创建对象, 但工厂方法用的是继承, 而抽象工厂通过对象的组合.

利用工厂方法创建对象, 需要扩展一个类(继承成子类), 并覆盖(或实现)它的工厂方法.

当需要创建产品家族和想让制造的相关产品集合起来时, 可以使用抽象工厂.

简单工厂, 虽然不是真正的设计模式, 但仍不失为一个简单的方法, 可以将客户程序从具体类解耦.

工厂方法使用继承: 把对象的创建委托给子类, 子类实现工厂方法来创建对象.

抽象工厂使用对象组合: 对象的创建被实现在工厂接口所暴露出来的方法中.

所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合.

工厂方法允许类将实例化延迟到子类进行.

抽象工厂创建相关的对象家族, 而不需要依赖它们的具体类.

依赖倒置原则, 指导我们避免依赖具体类型, 而要尽量依赖抽象.

工厂是很有威力的技巧, 帮助我们针对抽象编程, 而不要针对具体类编程.
