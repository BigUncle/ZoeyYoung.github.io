<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OK Computer</title><link>http://zoeyyoung.github.io/</link><description>It's better to burn out &lt;br/&gt; than to fade away.</description><atom:link href="http://zoeyyoung.github.io/feeds/she-ji-mo-shi.rss.xml" rel="self"></atom:link><lastBuildDate>Sun, 22 Sep 2013 00:00:00 +0800</lastBuildDate><item><title>[设计模式] 工厂模式</title><link>http://zoeyyoung.github.io/design-patten-factory.html</link><description>&lt;p&gt;初始化于: 2012-06-13&lt;/p&gt;
&lt;p&gt;更新: 2013-09-22&lt;/p&gt;
&lt;h3&gt;参考书籍&lt;/h3&gt;
&lt;p&gt;《Head First 设计模式》4 工厂模式 —— 烘烤OO的精华[本文主要是基于这本的笔记]&lt;/p&gt;
&lt;p&gt;《设计模式：可复用面向对象软件的基础》3.1 ABSTRACT FACTORY(抽象工厂) —— 对象创建型模式&lt;/p&gt;
&lt;p&gt;《设计模式：可复用面向对象软件的基础》3.3 FACTORY METHOD(工厂方法) —— 对象创建型模式&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;关键目的——"松耦合"&lt;/p&gt;
&lt;p&gt;除了使用new操作符之外, 还有更多制造对象的方法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例化&lt;/strong&gt;这个活动不应该总是公开地进行&lt;/p&gt;
&lt;p&gt;初始化经常造成&lt;strong&gt;"耦合"&lt;/strong&gt;问题&lt;/p&gt;
&lt;p&gt;针对接口编程, 可以隔离掉以后系统可能发生的一大堆改变.&lt;/p&gt;
&lt;p&gt;设计原则: 对扩展开放, 对修改关闭.&lt;/p&gt;
&lt;p&gt;有一些要实例化的具体类, 究竟实例化哪个类, 要在运行时由一些条件来决定, 一有变化或扩展, 必须重新打开这段代码进行检查和修改. 这部分就是代码中&lt;strong&gt;变化的&lt;/strong&gt;部分, 因此要考虑把它们从&lt;strong&gt;不变的&lt;/strong&gt;部分分离出来.&lt;/p&gt;
&lt;p&gt;比如生产比萨, 有许多种不同的比萨, 需要通过传入类型参数来判断到底要实例化哪种比萨, 但是比萨类型又增多了呢(总是会有新品种)? 此时你就必须修改创建对象的代码来支持更多类型的比萨(也有可能哪种比萨不生产了需要移除, 总之这部分是可变的).&lt;/p&gt;
&lt;p&gt;怎么做? —— 找出会变化的方面, 把它们从不变的部分分离出来.&lt;/p&gt;
&lt;p&gt;将创建对象的代码从普通方法中抽离, 放入另一个对象(工厂)中, 这个新对象只管如何创建具体对象.&lt;/p&gt;
&lt;p&gt;工厂(factory)处理创建对象的细节.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有的工厂都是用来封装对象的创建.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一开始的疑问:&lt;/p&gt;
&lt;p&gt;单独出来有什么好处, 有变化时还是得修改工厂对象.&lt;/p&gt;
&lt;p&gt;没考虑到的情况是: &lt;strong&gt;可能还有其它地方会利用这个工厂来创建对象,,这个工厂可以有许多客户.  因此, 当以后实现改变时,  只需修改这个类, 而不会导致所有创建相关对象的地方都要修改.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将创建对象的代码集中在一个对象或方法中, 可以避免代码中的重复, 并且更方便以后的维护. 这也意味着客户在实例化对象时, 只会依赖于接口, 而不是具体类.&lt;/p&gt;
&lt;p&gt;设计原则: 针对接口编程, 而不是针对实现编程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的理解&lt;/strong&gt;: 在我们系统中的很多地方可能都需要用到相同的一段代码 —— 这段代码用来创建对象, 返回的对象的类型是一些具体类型的&lt;strong&gt;抽象类型&lt;/strong&gt;, 创建的对象的&lt;strong&gt;具体类型&lt;/strong&gt;在运行时才能确定, 这段代码应该略复杂, 可能会有许多&lt;code&gt;if...else&lt;/code&gt;语句, 并且当系统需求变化, 比如加入新的具体类型时, 这段代码就需要修改 —— 这里应该很自然想到代码复用, 如果没有把这段代码提取出来, 当系统需求变化的时候, 许多地方都要同时修改, 这时候利用工厂就理所当然了. 另外一种理解就是, 既然有很多地方都要以相同的方式创建产品, 那把这些代码在一处管理总比到处都要管理来得强, 虽然你仍然需要实例化真正的对象(而不是抽象对象).&lt;/p&gt;
&lt;p&gt;把工厂定义成静态方法(静态工厂)的缺点: 不能通过继承来改变创建方法的行为.&lt;/p&gt;
&lt;h3&gt;定义简单工厂&lt;/h3&gt;
&lt;p&gt;简单工厂其实不是一个设计模式, 反而比较像是一种编程习惯.&lt;/p&gt;
&lt;p&gt;简单工厂由一个对象负责所有具体类的实例化(把全部的事情，在一个地方都处理完了), 任务太重.&lt;/p&gt;
&lt;p&gt;在简单工厂中, 工厂是另一个由Creator创建者使用的对象.(组合)&lt;/p&gt;
&lt;p&gt;简单工厂不具备工厂方法的弹性, 因为简单工厂不能变更正在创建的产品.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在设计模式中, 所谓的"实现一个接口"并"不一定"表示"写一个类, 并利用implement关键词来实现某个Java接口". "实现一个接口"泛指"实现某个超类型(可以是类或接口)的某个方法".&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;工厂方法模式&lt;/h3&gt;
&lt;p&gt;定义(意图): 工厂方法模式定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.&lt;/p&gt;
&lt;p&gt;工厂方法用来处理对象的创建, 并将这样的行为封装在&lt;strong&gt;子类&lt;/strong&gt;中. 这样, 客户程序中关于超类的代码就和子类对象创建代码解耦了.&lt;/p&gt;
&lt;p&gt;工厂方法是抽象的, 依赖子类来处理对象的创建.&lt;/p&gt;
&lt;p&gt;声明一个工厂方法&lt;/p&gt;
&lt;p&gt;原本是由一个对象负责所有具体类的实例化, 现在通过对超类(抽象创建者类)做一些转变, 变成由一群子类来负责实例化. 实例化的责任被移到一个"方法"中, 此方法就如同是一个"工厂".&lt;/p&gt;
&lt;p&gt;工厂方法用来处理对象的创建, 并将这样的行为封装在子类中.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;Product&lt;/span&gt; &lt;span class="nf"&gt;factoryMethod&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;工厂方法是抽象的, 所以依赖子类来处理对象的创建.(也可以不抽象, 提供默认行为)&lt;/li&gt;
&lt;li&gt;工厂方法必须返回一个产品. 超类中定义的方法, 通常使用到工厂方法的返回值.&lt;/li&gt;
&lt;li&gt;参数是可选的. 有参数时为"参数化工厂方法". 这里不一定要使用字符串, 可以创建代表参数类型的对象和使用静态常量或者Java 5支持的enum.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我的理解: 所有的产品都属于一个抽象产品类型A, 存在多个具体工厂的原因可能是可以对这些产品进行分类, 比如说有产品A1、A2、A3、A4、A5、A6都是A的子类, A1、A2、A3属于组1, A4、A5、A6属于组2, 具体工厂1生产组1, 具体工厂2生产组2, 工厂1只知道怎么生产组1的产品, 工厂2只知道怎么生产组2的产品, 这样就把产品的创建分配给多个子类了, 解决了简单工厂模式任务太重的缺点. 具体应用时要知道你要使用哪个具体工厂. (否则想象一下一堆的if...else...语句)&lt;/p&gt;
&lt;p&gt;有一个"抽象的"(这里说抽象的原因应该是它可能或大多数情况下会被继承, 但并不意味着一定是个抽象类)创建者类, 包含抽象工厂方法, 它实现了所有操纵产品的方法, 但不实现工厂方法(也可以定义一个默认的工厂方法来产生某些具体的产品, 这么一来, 即使创建者没有任何子类, 依然可以创建产品).&lt;/p&gt;
&lt;p&gt;相似的原则 —— 依赖倒置原则(Dependency Inversion Principle): 要依赖抽象, 不要依赖具体类.&lt;/p&gt;
&lt;p&gt;不能让高层组件依赖低层组件, 而且, 不管高层或低层组件, "两者"都应该依赖于抽象.&lt;/p&gt;
&lt;p&gt;我的理解: 上面的"抽象"工厂(高级组件), 不应该直接创建具体的产品(低层组件), 而应该只拥有抽象的产品(Product), 具体的产品由工厂方法创建, 高层组件并不关心具体生产出来的是什么产品, 因此它是依赖抽象的, 而低层组件只知道自己是抽象的产品的子类, 因此低层组件也只依赖于抽象.&lt;/p&gt;
&lt;p&gt;倒置在哪?&lt;/p&gt;
&lt;p&gt;本来高层组件依赖低层组件(许多箭头从上而下), 现在高层组件和低层组件都依赖同一个抽象, 这个抽象对于低层组件来说是高层的(箭头从下而上), 此时, 高层组件只有一条从上而下指向抽象的箭头.&lt;/p&gt;
&lt;p&gt;倒置思考方式&lt;/p&gt;
&lt;p&gt;一般: 先考虑高层, 然后考虑低层&lt;/p&gt;
&lt;p&gt;倒置后: 先考虑有许多低层组件, 然后抽象出一个接口, 而高层组件只需依赖这个抽象, 而不管低层组件怎样.&lt;/p&gt;
&lt;p&gt;指导方针(尽量, 而不是一定要遵循):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变量不可以持有具体类的引用&lt;/p&gt;
&lt;p&gt;如果使用new, 就会持有具体类的引用. 可以改用工厂来避开这样的做法.(这里的一个原因是类一般都是可变的, 用工厂可封装改变, 特例: 字符串不可变)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要让类派生自具体类&lt;/p&gt;
&lt;p&gt;如果派生自具体类, 就会依赖具体类. 应该派生自一个抽象(接口或抽象类).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要覆盖基类中已实现的方法.&lt;/p&gt;
&lt;p&gt;如果覆盖基类已实现的方法, 那么你的基类就不是一个真正适合被继承的抽象. 基类中已实现的方法, 应该由所有的子类共享。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;抽象工厂模式 Abstract Factory&lt;/h3&gt;
&lt;p&gt;对象创建型模式&lt;/p&gt;
&lt;p&gt;创建产品家族&lt;/p&gt;
&lt;p&gt;定义(意图): 抽象工厂模式提供一个接口, 用于创建(一系列)相关或相互依赖对象的家族, 而无需明确指定具体类.&lt;/p&gt;
&lt;p&gt;别名: Kit&lt;/p&gt;
&lt;p&gt;什么是产品家族?&lt;/p&gt;
&lt;p&gt;例如制作比萨所需要的原料.&lt;/p&gt;
&lt;p&gt;支持多种视感(look-and-feel)标准的用户界面工具包. 不同的视感风格为诸如滚动条、窗口和按钮等用户界面"窗口组件"定义不同的外观和行为. (每个软件使用的皮肤一类的)&lt;/p&gt;
&lt;p&gt;每个具体工厂都能够生产一整组的产品.(把一群相关的产品集合起来)&lt;/p&gt;
&lt;p&gt;适用性 —— 在以下情况可以使用Abstract Factory模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个系统要独立于它的产品的创建、组合和表示时&lt;/li&gt;
&lt;li&gt;一个系统要由多个产品系列中的一个来配置时&lt;/li&gt;
&lt;li&gt;当你要强调一系列相关的产品对象的设计以便进行联合使用时&lt;/li&gt;
&lt;li&gt;当你提供一个产品类库, 而只想显示它们的接口而不是实现时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽象工厂的方法经常以&lt;strong&gt;工厂方法&lt;/strong&gt;的方式实现. 抽象工厂的任务是定义一个负责创建一组产品的接口. 这个接口内的每个方法都负责创建一个具体产品, 同时我们利用实现抽象工厂的子类来提供这些具体的做法. 所以, 在抽象工厂中利用工厂方法实现生产方法是相当自然的做法.&lt;/p&gt;
&lt;p&gt;缺点: 如果加入新产品就必须改变接口, 所有的子类都要相应修改.&lt;/p&gt;
&lt;p&gt;&lt;img alt="抽象工厂模式结构" src="/static/images/抽象工厂模式结构.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Client仅使用由抽象工厂和抽象产品类声明的接口(解耦)&lt;/p&gt;
&lt;h3&gt;工厂方法和抽象工厂区别&lt;/h3&gt;
&lt;p&gt;工厂方法使用的是类, 而抽象工厂使用的是对象.&lt;/p&gt;
&lt;p&gt;都负责创建对象, 但工厂方法用的是&lt;strong&gt;继承&lt;/strong&gt;, 而抽象工厂通过&lt;strong&gt;对象的组合&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;利用工厂方法创建对象, 需要扩展一个类(继承成子类), 并覆盖(或实现)它的工厂方法.&lt;/p&gt;
&lt;p&gt;当需要创建产品家族和想让制造的相关产品集合起来时, 可以使用抽象工厂.&lt;/p&gt;
&lt;h3&gt;要点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有工厂都是用来封装对象的创建&lt;/li&gt;
&lt;li&gt;简单工厂, 虽然不是真正的设计模式, 但仍不失为一个简单的方法, 可以将客户程序从具体类解耦.&lt;/li&gt;
&lt;li&gt;工厂方法使用&lt;strong&gt;继承&lt;/strong&gt;: 把对象的创建委托给子类, 子类实现工厂方法来创建对象.&lt;/li&gt;
&lt;li&gt;抽象工厂使用&lt;strong&gt;对象组合&lt;/strong&gt;: 对象的创建被实现在工厂接口所暴露出来的方法中.&lt;/li&gt;
&lt;li&gt;所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合.&lt;/li&gt;
&lt;li&gt;工厂方法允许类将实例化延迟到子类进行.&lt;/li&gt;
&lt;li&gt;抽象工厂创建相关的对象家族, 而不需要依赖它们的具体类.&lt;/li&gt;
&lt;li&gt;依赖倒置原则, 指导我们避免依赖具体类型, 而要尽量依赖抽象.&lt;/li&gt;
&lt;li&gt;工厂是很有威力的技巧, 帮助我们针对抽象编程, 而不要针对具体类编程.&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Sun, 22 Sep 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-09-22:design-patten-factory.html</guid><category>读书</category><category>Book</category></item><item><title>[设计模式] 观察者模式</title><link>http://zoeyyoung.github.io/design-patten-observer.html</link><description>&lt;h3&gt;参考书籍&lt;/h3&gt;
&lt;p&gt;《Head First 设计模式》2 观察者(Observer)模式 —— 让你的对象知悉现况[本文主要是基于这本的笔记]&lt;/p&gt;
&lt;p&gt;《设计模式：可复用面向对象软件的基础》5.7 OBSERVER(观察者) —— 对象行为型模式&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;观察者模式是JDK中使用最多的模式之一.&lt;/p&gt;
&lt;p&gt;(手机中的后台通知. 天气通知. 新闻订阅. RSS订阅. 报纸和杂志的订阅.)&lt;/p&gt;
&lt;p&gt;出版者(Subject)+订阅者(Observer)=观察者模式&lt;/p&gt;
&lt;p&gt;定义: 观察者模式定义了对象之间的一对多依赖关系, 这样一来, 当一个对象改变状态时, 它的所有依赖者都会收到通知并自动更新.&lt;/p&gt;
&lt;p&gt;Java内置的观察者模式&lt;/p&gt;
&lt;p&gt;java.util.Observer &amp;lt;&lt;interface&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;java.util.Observable &amp;lt;&lt;class&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;相关描述查看&lt;a href="http://docs.oracle.com/javase/7/docs/api/"&gt;API文档&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Sun, 22 Sep 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-09-22:design-patten-observer.html</guid><category>读书</category><category>Book</category></item><item><title>[设计模式] 《设计模式：可复用面向对象软件的基础》</title><link>http://zoeyyoung.github.io/design-patten-book.html</link><description>&lt;p&gt;《设计模式：可复用面向对象软件的基础》&lt;/p&gt;
&lt;p&gt;设计模式依据目的可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型(Creational)&lt;/li&gt;
&lt;li&gt;结构型(Structural)&lt;/li&gt;
&lt;li&gt;行为型(Behavioral)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计模式按照范围分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类模式: 处理类和子类之间的关系, 这些关系通过继承建立, 是静态的, 在编辑时刻便确定下来了.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象模式: 处理对象间的关系, 这些关系在运行时刻是可以变化的, 更具有动态性.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建型类模式：将对象的部分创建工作延迟到子类；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;创建型对象模式：将对象的部分创建工作延迟到另一个对象中；&lt;/li&gt;
&lt;li&gt;结构型类模式：使用继承机制组合类；&lt;/li&gt;
&lt;li&gt;结构型对象模式：描述了对象的组装方式；&lt;/li&gt;
&lt;li&gt;行为型类模式：使用继承描述算法和控制流；&lt;/li&gt;
&lt;li&gt;行为型对象模式：描述一组对象怎样协作完成单个对象无法完成的任务；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计模式编目, 未说明类模式的默认为对象模式：&lt;/p&gt;
&lt;p&gt;创建型:&lt;/p&gt;
&lt;p&gt;1、Factory Method (类模式): 定义一个用于创建对象的接口, 让子类决定将哪一个类实例化. Factory Method使一个类的实例化延迟到其子类.&lt;/p&gt;
&lt;p&gt;2、Abstract Factory: 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类.&lt;/p&gt;
&lt;p&gt;3、Builder: 将一个复杂对象结构与它的表示分离，使得同样的构建过程可以创建不同的表示.&lt;/p&gt;
&lt;p&gt;4、Prototype: 用原型实例制定创建对象的种类, 并且通过拷贝这个原型来创建的对象.&lt;/p&gt;
&lt;p&gt;5、Singleton: 保证一个类仅有一个实例，并且提供一个访问它的全局访问点。&lt;/p&gt;
&lt;p&gt;结构型:&lt;/p&gt;
&lt;p&gt;1、Adapter(类模式): 通过类继承, 将一个类的接口转换成客户希望的另外一个接口. 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.&lt;/p&gt;
&lt;p&gt;2、Adapter: 通过对象组合, 将一个类的接口转换成客户希望的另外一个接口. 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.&lt;/p&gt;
&lt;p&gt;3、Bridge: 将抽象部分与它的显示部分分离, 使它们都可以独立地变化.&lt;/p&gt;
&lt;p&gt;4、Composite: 将对象组合成树形结构以表示“部分-整体”的层次结构. 使得客户对单个对象和复合对象的使用具有一致性.&lt;/p&gt;
&lt;p&gt;5、Decorator: 动态地给一个对象添加一些额外的职责. 就扩展功能而言, Decorator模式比生成子类方式更为灵活.&lt;/p&gt;
&lt;p&gt;6、Facade: 为子系统中的一组接口提供一个一致的界面, Facade模式定义了一个高层的接口, 这个接口使得这一子系统更加容易使用.&lt;/p&gt;
&lt;p&gt;7、Flyweight: 运用共享技术有效地支持大量细粒度的对象.&lt;/p&gt;
&lt;p&gt;8、Proxy: 为其他对象提供一个代理以控制对这个对象的访问.&lt;/p&gt;
&lt;p&gt;行为型:&lt;/p&gt;
&lt;p&gt;1、Interpreter(类模式): 给定一个语言，定义它的语法的一种表示, 并定义一个解释器, 该解释器使用该表示来解释语言中的语句.&lt;/p&gt;
&lt;p&gt;2、Template Method(类模式): 定义一个操作中的算法的骨架, 而将一些步骤延迟到子类中. 使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤.&lt;/p&gt;
&lt;p&gt;3、Chain Of Responsibility: 为清除请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。&lt;/p&gt;
&lt;p&gt;4、Command: 将一个请求封装为一个对象，从而使得可以用不同请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。&lt;/p&gt;
&lt;p&gt;5、Iterator: 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不需要暴露该对象的内部表示.&lt;/p&gt;
&lt;p&gt;6、Mediator: 用一个中介对象来封装一系列的对象交互, 中介者使得各对象不需要显式地相互引用，从而使得耦合度降低，而且可以独立地改变它们之间的交互。&lt;/p&gt;
&lt;p&gt;7、Memento: 在不破坏封装性的前提下, 捕获一个对象内部的状态, 并在该对象之外保存这个状态. 这样以后就可以将该对象恢复到保存状态.&lt;/p&gt;
&lt;p&gt;8、Observer: 定义对象的一种一对多的依赖关系, 以便当一个对象的状态发生改变时, 所有依赖于它的对象多得到通知并自动刷新.&lt;/p&gt;
&lt;p&gt;9、State: 允许一个对象在其内部状态改变时改变它的行为.对象看起来似乎修改了它所属的类.&lt;/p&gt;
&lt;p&gt;10、Strategy: 定义一系列的算法把它们一个个封装起来, 并且使它们可以相互替换. 本模式使得算法的变化可以独立于使用它的客户.&lt;/p&gt;
&lt;p&gt;11、Visitor: 表示一个作用于某对象结构中的各元素的操作, 它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Mon, 09 Sep 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-09-09:design-patten-book.html</guid><category>设计模式</category><category>书籍</category><category>笔记</category></item></channel></rss>