<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OK Computer</title><link>http://zoeyyoung.github.io/</link><description>It's better to burn out &lt;br/&gt; than to fade away.</description><atom:link href="http://zoeyyoung.github.io/feeds/she-ji-mo-shi.rss.xml" rel="self"></atom:link><lastBuildDate>Tue, 15 Oct 2013 00:00:00 +0800</lastBuildDate><item><title>[设计模式] 策略模式</title><link>http://zoeyyoung.github.io/design-patten-strategy.html</link><description>&lt;p&gt;STRATEGY(策略) —— 对象行为型模式&lt;/p&gt;
&lt;h3&gt;意图&lt;/h3&gt;
&lt;p&gt;定义一系列的算法, 把它们一个个封装起来, 且使它们可相互替换. 本模式使得算法可独
立于使用它的客户而变化.&lt;/p&gt;
&lt;h3&gt;别名&lt;/h3&gt;
&lt;p&gt;政策(Policy)&lt;/p&gt;
&lt;h3&gt;适用性&lt;/h3&gt;
&lt;p&gt;当存在以下情况时使用Strategy模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;许多相关的类仅仅是行为有异. "策略"提供了一种用多个行为中的一个行为来配置一个类的方法.&lt;/li&gt;
&lt;li&gt;需要使用一个算法的不同变体. 例如, 你可能会定义一些反映不同的空间/时间权衡的
算法. 当这些变体实现为一个算法的类层次时, 可以使用策略模式.&lt;/li&gt;
&lt;li&gt;算法使用客户不应该知道的数据. 可使用策略模式以避免暴露复杂的、与算法相关的数
据结构.&lt;/li&gt;
&lt;li&gt;一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现. 将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;结构&lt;/h3&gt;
&lt;p&gt;&lt;img alt="策略模式结构图" src="/static/images/design-patten-strategy.png" /&gt;&lt;/p&gt;
&lt;h3&gt;参与者&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Strategy(策略)&lt;ul&gt;
&lt;li&gt;定义所有支持的算法的公共接口. Context使用这个接口来调用某ConcreteStrategy定义的算法.【使用组合】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ConcreteStrategy(具体策略)&lt;ul&gt;
&lt;li&gt;以Strategy接口实现某具体算法.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Context(上下文)&lt;ul&gt;
&lt;li&gt;用一个ConcreteStrategy对象来配置.【setStrategy(Strategy concreteStrategy)】&lt;/li&gt;
&lt;li&gt;维护一个对Strategy对象的引用.&lt;/li&gt;
&lt;li&gt;可定义一个接口来让Strategy访问它的数据.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;协作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Strategy和Context相互作用以实现选定的算法. 当算法被调用时, Context可以将该算法所需要的所有数据都传递给该Strategy. 或者, Context可以将自身作为一个参数传递给Strategy操作. 这就让Strategy在需要时可以回调Context.
• Context将它的客户的请求转发给它的Strategy. 客户通常创建并传递一个ConcreteStrategy对象给该Context; 这样, 客户仅与Context交互. 通常有一系列的ConcreteStrategy类可供
客户从中选择.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;效果&lt;/h3&gt;
&lt;p&gt;优:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相关算法系列&lt;/li&gt;
&lt;li&gt;一个替代继承的方法&lt;/li&gt;
&lt;li&gt;消除了一些条件语句&lt;/li&gt;
&lt;li&gt;实现的选择&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户必须了解不同的 Strategy&lt;/li&gt;
&lt;li&gt;Strategy和Context之间的通信开销&lt;/li&gt;
&lt;li&gt;增加了对象的数目【使用Flyweight】&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;定义Strategy和Context接口&lt;/li&gt;
&lt;li&gt;将Strategy作为模板参数【C++】&lt;/li&gt;
&lt;li&gt;使Strategy对象成为可选的【常见, 在无Strategy时使用默认实现】&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;JDK&lt;/h3&gt;
&lt;p&gt;recognizeable by behavioral methods in an abstract/interface type which invokes a method in an implementation of a different abstract/interface type which has been passed-in as method argument into the strategy implementation&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html#compare%28T,%20T%29"&gt;java.util.Comparator#compare()&lt;/a&gt;, executed by among others Collections#sort().&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html"&gt;javax.servlet.http.HttpServlet&lt;/a&gt;, the &lt;code&gt;service()&lt;/code&gt; and all &lt;code&gt;doXXX()&lt;/code&gt; methods take &lt;code&gt;HttpServletRequest&lt;/code&gt; and &lt;code&gt;HttpServletResponse&lt;/code&gt; and the implementor has to process them (and not to get hold of them as instance variables!).&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter%28javax.servlet.ServletRequest,%20javax.servlet.ServletResponse,%20javax.servlet.FilterChain%29"&gt;javax.servlet.Filter#doFilter()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.oracle.com/javase/7/docs/api/java/io/File.html#list(java.io.FilenameFilter)"&gt;java.io.File#list()&lt;/a&gt; FilenameFilter作为Strategy, 其它带FilenameFilter参数的方法也是.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Tue, 15 Oct 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-10-15:design-patten-strategy.html</guid><category>读书</category><category>Book</category></item><item><title>[设计模式] Facade</title><link>http://zoeyyoung.github.io/design-patten-facade.html</link><description>&lt;h3&gt;意图&lt;/h3&gt;
&lt;p&gt;为子系统中的一组接口提供一个一致的界面, Facade模式定义了一个高层接口, 这个接口使得这一子系统更加容易使用.&lt;/p&gt;
&lt;h3&gt;适用性&lt;/h3&gt;
&lt;p&gt;在遇到以下情况使用Facade模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你要为一个复杂子系统提供一个简单接口时. 子系统往往因为不断演化而变得越来越复杂. 大多数模式使用时都会产生更多更小的类. 这使得子系统更具可重用性, 也更容易对子系统进行定制, 但这也给那些不需要定制子系统的用户带来一些使用上的困难. Facade可以提供一个简单的缺省视图, 这一视图对大多数用户来说已经足够, 而那些需要更多的可定制性的用户可以越过facade层.&lt;/li&gt;
&lt;li&gt;客户程序与抽象类的实现部分之间存在着很大的依赖性. 引入facade将这个子系统与客户以及其他的子系统分离, 可以提高子系统的独立性和可移植性.&lt;/li&gt;
&lt;li&gt;当你需要构建一个层次结构的子系统时, 使用facade模式定义子系统中每层的入口点. 如果子系统之间是相互依赖的, 你可以让它们仅通过facade进行通讯, 从而简化了它们之间的依赖关系.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Head First&lt;/h3&gt;
&lt;p&gt;外观模式(facade)改变接口的目的是&lt;strong&gt;简化接口&lt;/strong&gt;. 外观类没有对子系统进行封装, 只是提供了集合式简化的接口. 这其实是一个极朴素的概念, 不只是简化了接口, 也将客户从组件的子系统中解耦出来. 外观和适配器都可以包装多个类, 但是外观的&lt;strong&gt;意图&lt;/strong&gt;在于简化接口, 而适配器的意图在于将接口转换成不同的接口.&lt;/p&gt;
&lt;p&gt;家庭影院的外观模式例子, 将许许多多的组件动作结合在一起完成了一系列对用户来讲方便的方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;HomeTheaterFacade&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Amplifier&lt;/span&gt; &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Tuner&lt;/span&gt; &lt;span class="n"&gt;tuner&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DvdPlayer&lt;/span&gt; &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CdPlayer&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Projector&lt;/span&gt; &lt;span class="n"&gt;projector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TheaterLights&lt;/span&gt; &lt;span class="n"&gt;lights&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Screen&lt;/span&gt; &lt;span class="n"&gt;screen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PopcornPopper&lt;/span&gt; &lt;span class="n"&gt;popper&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;HomeTheaterFacade&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Amplifier&lt;/span&gt; &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;Tuner&lt;/span&gt; &lt;span class="n"&gt;tuner&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;DvdPlayer&lt;/span&gt; &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;CdPlayer&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;Projector&lt;/span&gt; &lt;span class="n"&gt;projector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;Screen&lt;/span&gt; &lt;span class="n"&gt;screen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;TheaterLights&lt;/span&gt; &lt;span class="n"&gt;lights&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;PopcornPopper&lt;/span&gt; &lt;span class="n"&gt;popper&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;amp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tuner&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tuner&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dvd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;projector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;projector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;screen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;screen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lights&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lights&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;popper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;popper&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//将每一个组件的引用传入该对象中&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;watchMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;movie&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Get ready to watch a movie...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;popper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;popper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;lights&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;screen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;down&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;projector&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;projector&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wideScreenMode&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setDvd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setSurroundSound&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setVolume&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;play&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;endMovie&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Shutting movie theater down...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;popper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;lights&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;screen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;projector&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eject&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;listenToCd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;cdTitle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Get ready for an audiopile experence...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;lights&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setVolume&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setCd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setStereoSound&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;play&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cdTitle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;endCd&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Shutting down CD...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setCd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eject&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;listenToRadio&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Tuning in the airwaves...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;tuner&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;tuner&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFrequency&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;frequency&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setVolume&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setTuner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tuner&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;endRadio&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Shutting down the tuner...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;tuner&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们使用这个外观模式就可以简单舒适的看一场电影了:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;HomeTheaterTestDrive&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Amplifier&lt;/span&gt; &lt;span class="n"&gt;amp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Amplifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Top-O-Line Amplifier&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Tuner&lt;/span&gt; &lt;span class="n"&gt;tuner&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Tuner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Top-O-Line AM/FM Tuner&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;DvdPlayer&lt;/span&gt; &lt;span class="n"&gt;dvd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;DvdPlayer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Top-O-Line DVD Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;CdPlayer&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;CdPlayer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Top-O-Line CD Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Projector&lt;/span&gt; &lt;span class="n"&gt;projector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Projector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Top-O-Line Projector&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;TheaterLights&lt;/span&gt; &lt;span class="n"&gt;lights&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TheaterLights&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Theater Ceiling Lights&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Screen&lt;/span&gt; &lt;span class="n"&gt;screen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Screen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Theater Screen&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;PopcornPopper&lt;/span&gt; &lt;span class="n"&gt;popper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;PopcornPopper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Popcorn Popper&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;HomeTheaterFacade&lt;/span&gt; &lt;span class="n"&gt;homeTheater&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
                &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HomeTheaterFacade&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tuner&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dvd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="n"&gt;projector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;screen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lights&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;popper&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;homeTheater&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;watchMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Raiders of the Lost Ark&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;homeTheater&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endMovie&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们由此引入一个新的OO原则——最少知识(Least Knowledge)原则(也就是传说中的Law of Demeter): 只和你的密友谈话. 也就是说, 当你正在设计一个系统时不管是任何对象, 你都要注意它所交互的类有哪些, 并注意它和这些类是如何交互的. 尽量减少类之间的依赖. 针对这个原则, 我们有一系列的准则可以遵循: 对于任何对象, 在其内部的方法中, 我们只应该调用属于以下范围的方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该对象本身。&lt;/li&gt;
&lt;li&gt;被当做方法的参数而传递进来的对象。&lt;/li&gt;
&lt;li&gt;此方法所创建或实例化的任何对象。&lt;/li&gt;
&lt;li&gt;对象中的其他任何的对象成员和方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举一个汽车的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;car&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Engine&lt;/span&gt; &lt;span class="n"&gt;engine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 类中的组件, 我们可以调用它的方法&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;Doors&lt;/span&gt; &lt;span class="n"&gt;doors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Doors&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 方法创建的对象, 我们可以调用它的方法&lt;/span&gt;
        &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;authorized&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;turns&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 传入的参数, 我们可以调用它的方法&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;authorized&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;engine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;updateDashboardDisplay&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 对象中的方法, 我们可以调用&lt;/span&gt;
            &lt;span class="n"&gt;doors&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;updateDashboardDisplay&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不要对某个调用其他方法返回的对象进行方法的调用, 我们若是这么做就相当于向另一个对象的子部分发请求, 耦合性就会加大. 但是这个原则也会带来一些弊端, 导致更多的"包装"类被制造出来, 以处理和其他组件的沟通, 增加程序复杂度和运行时的性能.&lt;/p&gt;
&lt;p&gt;我们再举书中一个练习题的例子仔细看看这个相当基本且重要的原则:&lt;/p&gt;
&lt;p&gt;一个不符合这个原则的案例:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;House&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WeatherStation&lt;/span&gt; &lt;span class="n"&gt;station&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;getTemp&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;station&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getThermometer&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getTemperature&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个getTemp方法中涉及了一个调用返回的对象.&lt;/p&gt;
&lt;p&gt;而我们把这个方法拆开就可以得到一个符合这个原则的案例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;House&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WeatherStation&lt;/span&gt; &lt;span class="n"&gt;station&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;getTemp&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;Thermometer&lt;/span&gt; &lt;span class="n"&gt;thermometer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;station&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getThermometer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;getTempHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thermometer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;getTemperHelp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Thermometer&lt;/span&gt; &lt;span class="n"&gt;thermometer&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;thermometer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getTemperature&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是这有意义吗? 在这个简单的例子中恐怕是没有的. 其实我们经常用到违反该原则的例子, 比如&lt;code&gt;System.out.println&lt;/code&gt;……, 这就告诉我们这并非是金科玉律. 有好有坏吧, 凡事有得有失, 在外观模式中, 我们看到HomeTheaterFacade类是遵循这个原则的, 这就主要带来好处: 一个组件的更换和升级不影响我们通过HomeTheaterTestDrive这个测试类中的主函数去轻松的看一场电影.&lt;/p&gt;
&lt;h3&gt;更多&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Facade_pattern"&gt;维基: Facade pattern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;举了一个电脑启动的例子. 我们只要按开机按钮, 但计算机内部帮我们做了一堆事情, 包括CPU、内存、硬盘等对象互相交互.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Tue, 08 Oct 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-10-08:design-patten-facade.html</guid><category>读书</category><category>Book</category></item><item><title>[设计模式] 职责链模式</title><link>http://zoeyyoung.github.io/design-pattern-chain-of-responsibility.html</link><description>&lt;h3&gt;联想&lt;/h3&gt;
&lt;p&gt;击鼓传花&lt;/p&gt;
&lt;h3&gt;意图&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Chain_of_responsibility_pattern"&gt;Chain Of Responsibility&lt;/a&gt;: 为清除请求的发送者和接受者之间的耦合, 而使多个对象都有机会处理这个请求. 将这些对象连成一条链, 并沿着这条链传递该请求, 直到有一个对象处理它.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.programcreek.com/2013/02/java-design-pattern-chain-of-responsibility/"&gt;Java Design Pattern: Chain of Responsibility&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;JDK&lt;/h3&gt;
&lt;p&gt;Chain of responsibility (recognizeable by behavioral methods which (indirectly) invokes the same method in another implementation of same abstract/interface type in a queue)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.oracle.com/javase/7/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29"&gt;java.util.logging.Logger#log()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter%28javax.servlet.ServletRequest,%20javax.servlet.ServletResponse,%20javax.servlet.FilterChain%29"&gt;javax.servlet.Filter#doFilter()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Tue, 08 Oct 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-10-08:design-pattern-chain-of-responsibility.html</guid><category>读书</category><category>Book</category><category>设计模式</category></item><item><title>[设计模式] Adapter</title><link>http://zoeyyoung.github.io/design-patten-adapter.html</link><description>&lt;h3&gt;意图:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Adapter(类模式): 通过类继承, 将一个类的接口转换成客户希望的另外一个接口. 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adapter: 通过对象组合, 将一个类的接口转换成客户希望的另外一个接口. 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;别名: 包装器 Wrapper&lt;/h3&gt;
&lt;h3&gt;适用性&lt;/h3&gt;
&lt;p&gt;以下情况使用Adapter模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你想使用一个已经存在的类, 而它的接口不符合你的需求.&lt;/li&gt;
&lt;li&gt;你想创建一个可以复用的类, 该类可以与其他不相关的类或不可预见的类(即那些接口
可能不一定兼容的类)协同工作.&lt;/li&gt;
&lt;li&gt;(仅适用于对象Adapter)你想使用一些已经存在的子类, 但是不可能对每一个都进行
子类化以匹配它们的接口. 对象适配器可以适配它的父类接口.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Head First&lt;/h3&gt;
&lt;p&gt;&lt;img alt="适配器" src="/static/images/适配器.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;1.真实世界的适配器: 交流电适配器. 【想想相机那个充电器.】&lt;/p&gt;
&lt;p&gt;2.构造适配器的关键: 实现了目标接口, 并持有被适配者的实例.&lt;/p&gt;
&lt;p&gt;举一个火鸡冒充鸭子的适配器例子:&lt;/p&gt;
&lt;p&gt;我们定义两个东西:&lt;/p&gt;
&lt;p&gt;一个是鸭子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Duck&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;quack&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个是火鸡：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Turkey&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;gobble&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们现在做的就是要让火鸡有能力去冒充鸭子, 因为接口不同, 因此需要适配器:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TurkeyAdapter&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Duck&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 需要实现客户想看到的接口&lt;/span&gt;
    &lt;span class="n"&gt;Turkey&lt;/span&gt; &lt;span class="n"&gt;turkey&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;TurkeyAdapter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Turkey&lt;/span&gt; &lt;span class="n"&gt;turkey&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 利用构造器取得要被适配的对象的引用&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;turkey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;turkey&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 下面实现接口中所有的方法.&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;quack&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;turkey&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;gobble&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;fly&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;turkey&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fly&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这个类似于一种能力转换器的类中, 我们首先指定了我们转换为Duck的能力(&lt;strong&gt;implements Duck&lt;/strong&gt;), 而这个能力的实际提供者 —— Turkey则被我们以成员变量的形式置于这个类内部(&lt;strong&gt;Turkey turkey;&lt;/strong&gt;)并且在这个类构造对象时传入(&lt;strong&gt;public TurkeyAdapter(Turkey turkey)&lt;/strong&gt;). 下一步就是具体定义这些能力的时候了——也就是把接口定义的方法都对应实现.&lt;/p&gt;
&lt;p&gt;在使用的时候, 我们的意图是让火鸡冒充鸭子, 那么我们要先建立一个火鸡, 然后建立一个能力转换器(&lt;strong&gt;new TurkeyAdapter(turkey)&lt;/strong&gt;), 把我们建立好的火鸡传进去处理, 这样得到的一个对象(&lt;strong&gt;turkeyAdapter&lt;/strong&gt;)就可以完全当做一个鸭子使用了.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DuckTestDrive&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;WildTurkey&lt;/span&gt; &lt;span class="n"&gt;turkey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;WildTurkey&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Duck&lt;/span&gt; &lt;span class="n"&gt;turkeyAdapter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TurkeyAdapter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;turkey&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;testDuck&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;turkeyAdapter&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;testDuck&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Duck&lt;/span&gt; &lt;span class="n"&gt;duck&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;duck&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;quack&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;duck&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fly&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的设计体现了良好的OO设计原则: 使用对象组合, 包装被适配者. 并且它是通过接口进行组合将二者绑定起来, 而不是实现——这就是一个对象适配器的设计观念.&lt;/p&gt;
&lt;p&gt;3.类适配器与对象适配器不同之处在于: 类适配器使用继承的方式, 多重继承了被适配者(此例中为火鸡)和目标适配者(此例中为鸭子)两者. 而对象适配器则实现了鸭子的接口, 在具体调用时则通过内部的火鸡成员变量提供具体真实的能力, 通过这样的方式将两者组合起来. 通过对比, 我们能得到如下一些特点:&lt;/p&gt;
&lt;p&gt;对象适配器不但能适配某一个类, 而且还可以适配该类的任意子类, 另外实现的方法可以由多个方法搭配完成, 这样更具有弹性.&lt;/p&gt;
&lt;p&gt;类适配器则只在需要的时候使用覆盖来实现一些方法, 而不用像对象适配器一样实现整个被适配者的各种方法, 因为它可以直接使用继承, 更加有效率.&lt;/p&gt;
&lt;p&gt;另外需要说明的是: 由于Java中无法提供多重继承, 所以无法轻易实现类适配器这个层面的东西.&lt;/p&gt;
&lt;p&gt;4.在Sun Java中一个实际使用适配器的例子就是&lt;strong&gt;Iterator接口&lt;/strong&gt;, 它实现了对集合类型的遍历.&lt;/p&gt;
&lt;p&gt;5.你可能发现一个事情: 装饰者模式和适配器模式貌似比较相像, 我们做一下比较：&lt;/p&gt;
&lt;p&gt;装饰者需要有一些新的行为或者职责要加入到设计中, 并且动态的进行添加处理, 而适配器模式则是需要将一个能力转换为另一个能力, 静态敲定了一些能力. 装饰者也可以做到能力转换, 而且还支持新行为的加入, 适配器只是装饰者的一种变体, 都是用来包装对象的. 而从另外的角度, 适配器一定会对接口进行转换, 而装饰者一定不会. 从意图上说, 装饰者是被改变接口而扩展包装对象的行为或者职责, 而适配器则是为了转换包装对象的行为来改变接口.&lt;/p&gt;
&lt;p&gt;比较:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装饰者模式 将对象包装起来, 赋予它们新的职责&lt;/li&gt;
&lt;li&gt;适配器模式 将类的接口转换成想要的接口&lt;/li&gt;
&lt;li&gt;外观模式 将对象包装起来以简化其接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.programcreek.com/2011/09/java-design-pattern-adapter/"&gt;Programcreek: Java Design Pattern: Adapter&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Wed, 02 Oct 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-10-02:design-patten-adapter.html</guid><category>读书</category><category>Book</category></item><item><title>[设计模式] 工厂模式</title><link>http://zoeyyoung.github.io/design-patten-factory.html</link><description>&lt;p&gt;初始化于: 2012-06-13&lt;/p&gt;
&lt;p&gt;更新: 2013-09-22&lt;/p&gt;
&lt;h3&gt;参考书籍&lt;/h3&gt;
&lt;p&gt;《Head First 设计模式》4 工厂模式 —— 烘烤OO的精华[本文主要是基于这本的笔记]&lt;/p&gt;
&lt;p&gt;《设计模式：可复用面向对象软件的基础》3.1 ABSTRACT FACTORY(抽象工厂) —— 对象创建型模式&lt;/p&gt;
&lt;p&gt;《设计模式：可复用面向对象软件的基础》3.3 FACTORY METHOD(工厂方法) —— 对象创建型模式&lt;/p&gt;
&lt;h3&gt;相关博文&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.programcreek.com/2013/02/java-design-pattern-factory/"&gt;Programcreek: Java Design Pattern: Factory&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.programcreek.com/2013/02/java-design-pattern-abstract-factory/"&gt;Programcreek: Java Design Pattern: Abstract Factory&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;关键目的——"松耦合"&lt;/p&gt;
&lt;p&gt;除了使用new操作符之外, 还有更多制造对象的方法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例化&lt;/strong&gt;这个活动不应该总是公开地进行&lt;/p&gt;
&lt;p&gt;初始化经常造成&lt;strong&gt;"耦合"&lt;/strong&gt;问题&lt;/p&gt;
&lt;p&gt;针对接口编程, 可以隔离掉以后系统可能发生的一大堆改变.&lt;/p&gt;
&lt;p&gt;设计原则: 对扩展开放, 对修改关闭.&lt;/p&gt;
&lt;p&gt;有一些要实例化的具体类, 究竟实例化哪个类, 要在运行时由一些条件来决定, 一有变化或扩展, 必须重新打开这段代码进行检查和修改. 这部分就是代码中&lt;strong&gt;变化的&lt;/strong&gt;部分, 因此要考虑把它们从&lt;strong&gt;不变的&lt;/strong&gt;部分分离出来.&lt;/p&gt;
&lt;p&gt;比如生产比萨, 有许多种不同的比萨, 需要通过传入类型参数来判断到底要实例化哪种比萨, 但是比萨类型又增多了呢(总是会有新品种)? 此时你就必须修改创建对象的代码来支持更多类型的比萨(也有可能哪种比萨不生产了需要移除, 总之这部分是可变的).&lt;/p&gt;
&lt;p&gt;怎么做? —— 找出会变化的方面, 把它们从不变的部分分离出来.&lt;/p&gt;
&lt;p&gt;将创建对象的代码从普通方法中抽离, 放入另一个对象(工厂)中, 这个新对象只管如何创建具体对象.&lt;/p&gt;
&lt;p&gt;工厂(factory)处理创建对象的细节.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有的工厂都是用来封装对象的创建.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一开始的疑问:&lt;/p&gt;
&lt;p&gt;单独出来有什么好处, 有变化时还是得修改工厂对象.&lt;/p&gt;
&lt;p&gt;没考虑到的情况是: &lt;strong&gt;可能还有其它地方会利用这个工厂来创建对象,,这个工厂可以有许多客户.  因此, 当以后实现改变时,  只需修改这个类, 而不会导致所有创建相关对象的地方都要修改.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将创建对象的代码集中在一个对象或方法中, 可以避免代码中的重复, 并且更方便以后的维护. 这也意味着客户在实例化对象时, 只会依赖于接口, 而不是具体类.&lt;/p&gt;
&lt;p&gt;设计原则: 针对接口编程, 而不是针对实现编程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的理解&lt;/strong&gt;: 在我们系统中的很多地方可能都需要用到相同的一段代码 —— 这段代码用来创建对象, 返回的对象的类型是一些具体类型的&lt;strong&gt;抽象类型&lt;/strong&gt;, 创建的对象的&lt;strong&gt;具体类型&lt;/strong&gt;在运行时才能确定, 这段代码应该略复杂, 可能会有许多&lt;code&gt;if...else&lt;/code&gt;语句, 并且当系统需求变化, 比如加入新的具体类型时, 这段代码就需要修改 —— 这里应该很自然想到代码复用, 如果没有把这段代码提取出来, 当系统需求变化的时候, 许多地方都要同时修改, 这时候利用工厂就理所当然了. 另外一种理解就是, 既然有很多地方都要以相同的方式创建产品, 那把这些代码在一处管理总比到处都要管理来得强, 虽然你仍然需要实例化真正的对象(而不是抽象对象).&lt;/p&gt;
&lt;p&gt;把工厂定义成静态方法(静态工厂)的缺点: 不能通过继承来改变创建方法的行为.&lt;/p&gt;
&lt;h3&gt;定义简单工厂&lt;/h3&gt;
&lt;p&gt;简单工厂其实不是一个设计模式, 反而比较像是一种编程习惯.&lt;/p&gt;
&lt;p&gt;简单工厂由一个对象负责所有具体类的实例化(把全部的事情，在一个地方都处理完了), 任务太重.&lt;/p&gt;
&lt;p&gt;在简单工厂中, 工厂是另一个由Creator创建者使用的对象.(组合)&lt;/p&gt;
&lt;p&gt;简单工厂不具备工厂方法的弹性, 因为简单工厂不能变更正在创建的产品.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在设计模式中, 所谓的"实现一个接口"并"不一定"表示"写一个类, 并利用implement关键词来实现某个Java接口". "实现一个接口"泛指"实现某个超类型(可以是类或接口)的某个方法".&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;工厂方法模式&lt;/h3&gt;
&lt;p&gt;定义(意图): 工厂方法模式定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.&lt;/p&gt;
&lt;p&gt;工厂方法用来处理对象的创建, 并将这样的行为封装在&lt;strong&gt;子类&lt;/strong&gt;中. 这样, 客户程序中关于超类的代码就和子类对象创建代码解耦了.&lt;/p&gt;
&lt;p&gt;工厂方法是抽象的, 依赖子类来处理对象的创建.&lt;/p&gt;
&lt;p&gt;声明一个工厂方法&lt;/p&gt;
&lt;p&gt;原本是由一个对象负责所有具体类的实例化, 现在通过对超类(抽象创建者类)做一些转变, 变成由一群子类来负责实例化. 实例化的责任被移到一个"方法"中, 此方法就如同是一个"工厂".&lt;/p&gt;
&lt;p&gt;工厂方法用来处理对象的创建, 并将这样的行为封装在子类中.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;Product&lt;/span&gt; &lt;span class="nf"&gt;factoryMethod&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;工厂方法是抽象的, 所以依赖子类来处理对象的创建.(也可以不抽象, 提供默认行为)&lt;/li&gt;
&lt;li&gt;工厂方法必须返回一个产品. 超类中定义的方法, 通常使用到工厂方法的返回值.&lt;/li&gt;
&lt;li&gt;参数是可选的. 有参数时为"参数化工厂方法". 这里不一定要使用字符串, 可以创建代表参数类型的对象和使用静态常量或者Java 5支持的enum.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我的理解: 所有的产品都属于一个抽象产品类型A, 存在多个具体工厂的原因可能是可以对这些产品进行分类, 比如说有产品A1、A2、A3、A4、A5、A6都是A的子类, A1、A2、A3属于组1, A4、A5、A6属于组2, 具体工厂1生产组1, 具体工厂2生产组2, 工厂1只知道怎么生产组1的产品, 工厂2只知道怎么生产组2的产品, 这样就把产品的创建分配给多个子类了, 解决了简单工厂模式任务太重的缺点. 具体应用时要知道你要使用哪个具体工厂. (否则想象一下一堆的if...else...语句)&lt;/p&gt;
&lt;p&gt;有一个"抽象的"(这里说抽象的原因应该是它可能或大多数情况下会被继承, 但并不意味着一定是个抽象类)创建者类, 包含抽象工厂方法, 它实现了所有操纵产品的方法, 但不实现工厂方法(也可以定义一个默认的工厂方法来产生某些具体的产品, 这么一来, 即使创建者没有任何子类, 依然可以创建产品).&lt;/p&gt;
&lt;p&gt;相似的原则 —— 依赖倒置原则(Dependency Inversion Principle): 要依赖抽象, 不要依赖具体类.&lt;/p&gt;
&lt;p&gt;不能让高层组件依赖低层组件, 而且, 不管高层或低层组件, "两者"都应该依赖于抽象.&lt;/p&gt;
&lt;p&gt;我的理解: 上面的"抽象"工厂(高级组件), 不应该直接创建具体的产品(低层组件), 而应该只拥有抽象的产品(Product), 具体的产品由工厂方法创建, 高层组件并不关心具体生产出来的是什么产品, 因此它是依赖抽象的, 而低层组件只知道自己是抽象的产品的子类, 因此低层组件也只依赖于抽象.&lt;/p&gt;
&lt;p&gt;倒置在哪?&lt;/p&gt;
&lt;p&gt;本来高层组件依赖低层组件(许多箭头从上而下), 现在高层组件和低层组件都依赖同一个抽象, 这个抽象对于低层组件来说是高层的(箭头从下而上), 此时, 高层组件只有一条从上而下指向抽象的箭头.&lt;/p&gt;
&lt;p&gt;倒置思考方式&lt;/p&gt;
&lt;p&gt;一般: 先考虑高层, 然后考虑低层&lt;/p&gt;
&lt;p&gt;倒置后: 先考虑有许多低层组件, 然后抽象出一个接口, 而高层组件只需依赖这个抽象, 而不管低层组件怎样.&lt;/p&gt;
&lt;p&gt;指导方针(尽量, 而不是一定要遵循):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变量不可以持有具体类的引用&lt;/p&gt;
&lt;p&gt;如果使用new, 就会持有具体类的引用. 可以改用工厂来避开这样的做法.(这里的一个原因是类一般都是可变的, 用工厂可封装改变, 特例: 字符串不可变)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要让类派生自具体类&lt;/p&gt;
&lt;p&gt;如果派生自具体类, 就会依赖具体类. 应该派生自一个抽象(接口或抽象类).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要覆盖基类中已实现的方法.&lt;/p&gt;
&lt;p&gt;如果覆盖基类已实现的方法, 那么你的基类就不是一个真正适合被继承的抽象. 基类中已实现的方法, 应该由所有的子类共享。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;抽象工厂模式 Abstract Factory&lt;/h3&gt;
&lt;p&gt;对象创建型模式&lt;/p&gt;
&lt;p&gt;创建产品家族&lt;/p&gt;
&lt;p&gt;定义(意图): 抽象工厂模式提供一个接口, 用于创建(一系列)相关或相互依赖对象的家族, 而无需明确指定具体类.&lt;/p&gt;
&lt;p&gt;别名: Kit&lt;/p&gt;
&lt;p&gt;什么是产品家族?&lt;/p&gt;
&lt;p&gt;例如制作比萨所需要的原料.&lt;/p&gt;
&lt;p&gt;支持多种视感(look-and-feel)标准的用户界面工具包. 不同的视感风格为诸如滚动条、窗口和按钮等用户界面"窗口组件"定义不同的外观和行为. (每个软件使用的皮肤一类的)&lt;/p&gt;
&lt;p&gt;每个具体工厂都能够生产一整组的产品.(把一群相关的产品集合起来)&lt;/p&gt;
&lt;p&gt;适用性 —— 在以下情况可以使用Abstract Factory模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个系统要独立于它的产品的创建、组合和表示时&lt;/li&gt;
&lt;li&gt;一个系统要由多个产品系列中的一个来配置时&lt;/li&gt;
&lt;li&gt;当你要强调一系列相关的产品对象的设计以便进行联合使用时&lt;/li&gt;
&lt;li&gt;当你提供一个产品类库, 而只想显示它们的接口而不是实现时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽象工厂的方法经常以&lt;strong&gt;工厂方法&lt;/strong&gt;的方式实现. 抽象工厂的任务是定义一个负责创建一组产品的接口. 这个接口内的每个方法都负责创建一个具体产品, 同时我们利用实现抽象工厂的子类来提供这些具体的做法. 所以, 在抽象工厂中利用工厂方法实现生产方法是相当自然的做法.&lt;/p&gt;
&lt;p&gt;缺点: 如果加入新产品就必须改变接口, 所有的子类都要相应修改.&lt;/p&gt;
&lt;p&gt;&lt;img alt="抽象工厂模式结构" src="/static/images/抽象工厂模式结构.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Client仅使用由抽象工厂和抽象产品类声明的接口(解耦)&lt;/p&gt;
&lt;h3&gt;工厂方法和抽象工厂区别&lt;/h3&gt;
&lt;p&gt;工厂方法使用的是类, 而抽象工厂使用的是对象.&lt;/p&gt;
&lt;p&gt;都负责创建对象, 但工厂方法用的是&lt;strong&gt;继承&lt;/strong&gt;, 而抽象工厂通过&lt;strong&gt;对象的组合&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;利用工厂方法创建对象, 需要扩展一个类(继承成子类), 并覆盖(或实现)它的工厂方法.&lt;/p&gt;
&lt;p&gt;当需要创建产品家族和想让制造的相关产品集合起来时, 可以使用抽象工厂.&lt;/p&gt;
&lt;h3&gt;要点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有工厂都是用来封装对象的创建&lt;/li&gt;
&lt;li&gt;简单工厂, 虽然不是真正的设计模式, 但仍不失为一个简单的方法, 可以将客户程序从具体类解耦.&lt;/li&gt;
&lt;li&gt;工厂方法使用&lt;strong&gt;继承&lt;/strong&gt;: 把对象的创建委托给子类, 子类实现工厂方法来创建对象.&lt;/li&gt;
&lt;li&gt;抽象工厂使用&lt;strong&gt;对象组合&lt;/strong&gt;: 对象的创建被实现在工厂接口所暴露出来的方法中.&lt;/li&gt;
&lt;li&gt;所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合.&lt;/li&gt;
&lt;li&gt;工厂方法允许类将实例化延迟到子类进行.&lt;/li&gt;
&lt;li&gt;抽象工厂创建相关的对象家族, 而不需要依赖它们的具体类.&lt;/li&gt;
&lt;li&gt;依赖倒置原则, 指导我们避免依赖具体类型, 而要尽量依赖抽象.&lt;/li&gt;
&lt;li&gt;工厂是很有威力的技巧, 帮助我们针对抽象编程, 而不要针对具体类编程.&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Sun, 22 Sep 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-09-22:design-patten-factory.html</guid><category>读书</category><category>Book</category></item><item><title>[设计模式] 观察者模式</title><link>http://zoeyyoung.github.io/design-patten-observer.html</link><description>&lt;h3&gt;参考书籍&lt;/h3&gt;
&lt;p&gt;《Head First 设计模式》2 观察者(Observer)模式 —— 让你的对象知悉现况[本文主要是基于这本的笔记]&lt;/p&gt;
&lt;p&gt;《设计模式：可复用面向对象软件的基础》5.7 OBSERVER(观察者) —— 对象行为型模式&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;观察者模式是JDK中使用最多的模式之一.&lt;/p&gt;
&lt;p&gt;(手机中的后台通知. 天气通知. 新闻订阅. RSS订阅. 报纸和杂志的订阅.)&lt;/p&gt;
&lt;p&gt;出版者(Subject)+订阅者(Observer)=观察者模式&lt;/p&gt;
&lt;p&gt;定义: 观察者模式定义了对象之间的一对多依赖关系, 这样一来, 当一个对象改变状态时, 它的所有依赖者都会收到通知并自动更新.&lt;/p&gt;
&lt;p&gt;Java内置的观察者模式&lt;/p&gt;
&lt;p&gt;java.util.Observer &amp;lt;&lt;interface&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;java.util.Observable &amp;lt;&lt;class&gt;&amp;gt; —— 不是接口, 必须继承. 限制了它的使用和复用. 不能使用组合, 因为存在受保护(protected)的方法.&lt;/p&gt;
&lt;p&gt;相关描述查看&lt;a href="http://docs.oracle.com/javase/7/docs/api/"&gt;API文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在JavaBeans和Swing中, 也都实现了观察者模式.&lt;/p&gt;
&lt;p&gt;PropertyChangeListener接口&lt;/p&gt;
&lt;p&gt;ActionListener&lt;/p&gt;
&lt;p&gt;MVC&lt;/p&gt;
&lt;h3&gt;要点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;观察者模式定义了对象之间一对多的关系&lt;/li&gt;
&lt;li&gt;主题(也就是可观察者)用一个共同的接口来更新观察者&lt;/li&gt;
&lt;li&gt;观察者和可观察者之间用松耦合方式结合(loosecoupling), 可观察者不知道观察者的细节, 只知道观察者实现了观察者接口&lt;/li&gt;
&lt;li&gt;使用此模式时, 你可从被观察者处推(push)或拉(pull)数据(然而, 推的方式被认为更"正确")&lt;/li&gt;
&lt;li&gt;有多个观察者时, 不可以依赖特定的通知次序&lt;/li&gt;
&lt;li&gt;Java有多种观察者模式的实现, 包括了通用的java.util.Observable&lt;/li&gt;
&lt;li&gt;要注意java.util.Observable实现上所带来的一些问题&lt;/li&gt;
&lt;li&gt;如果有必要的话, 可以实现自己的Observable&lt;/li&gt;
&lt;li&gt;Swing大量使用观察者模式, 许多GUI框架也是如此&lt;/li&gt;
&lt;li&gt;此模式也被应用在许多地方, 例如: JavaBeans、RMI&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;JDK&lt;/h3&gt;
&lt;p&gt;Observer (or Publish/Subscribe) (recognizeable by behavioral methods which invokes a method on an instance of another abstract/interface type, depending on own state)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.oracle.com/javase/7/docs/api/java/util/Observer.html"&gt;java.util.Observer&lt;/a&gt; / &lt;a href="http://docs.oracle.com/javase/7/docs/api/java/util/Observable.html"&gt;java.util.Observable&lt;/a&gt; (rarely used in real world though)&lt;/li&gt;
&lt;li&gt;All implementations of &lt;a href="http://docs.oracle.com/javase/7/docs/api/java/util/EventListener.html"&gt;java.util.EventListener&lt;/a&gt; (practically all over Swing thus)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html"&gt;javax.servlet.http.HttpSessionBindingListener&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionAttributeListener.html"&gt;javax.servlet.http.HttpSessionAttributeListener&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.oracle.com/javaee/7/api/javax/faces/event/PhaseListener.html"&gt;javax.faces.event.PhaseListener&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Sun, 22 Sep 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-09-22:design-patten-observer.html</guid><category>读书</category><category>Book</category><category>设计模式</category></item><item><title>[设计模式] 《设计模式：可复用面向对象软件的基础》</title><link>http://zoeyyoung.github.io/design-patten-book.html</link><description>&lt;p&gt;链接为维基中相应词条.&lt;/p&gt;
&lt;p&gt;《设计模式：可复用面向对象软件的基础》&lt;/p&gt;
&lt;p&gt;设计模式依据目的可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型(Creational)&lt;/li&gt;
&lt;li&gt;结构型(Structural)&lt;/li&gt;
&lt;li&gt;行为型(Behavioral)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计模式按照范围分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类模式: 处理类和子类之间的关系, 这些关系通过继承建立, 是静态的, 在编辑时刻便确定下来了.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象模式: 处理对象间的关系, 这些关系在运行时刻是可以变化的, 更具有动态性.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建型类模式：将对象的部分创建工作延迟到子类；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;创建型对象模式：将对象的部分创建工作延迟到另一个对象中；&lt;/li&gt;
&lt;li&gt;结构型类模式：使用继承机制组合类；&lt;/li&gt;
&lt;li&gt;结构型对象模式：描述了对象的组装方式；&lt;/li&gt;
&lt;li&gt;行为型类模式：使用继承描述算法和控制流；&lt;/li&gt;
&lt;li&gt;行为型对象模式：描述一组对象怎样协作完成单个对象无法完成的任务；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计模式编目, 未说明类模式的默认为对象模式：&lt;/p&gt;
&lt;h3&gt;创建型&lt;/h3&gt;
&lt;p&gt;1、Factory Method (类模式): 定义一个用于创建对象的接口, 让子类决定将哪一个类实例化. Factory Method使一个类的实例化延迟到其子类.&lt;/p&gt;
&lt;p&gt;2、Abstract Factory: 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类.&lt;/p&gt;
&lt;p&gt;3、Builder: 将一个复杂对象结构与它的表示分离，使得同样的构建过程可以创建不同的表示.&lt;/p&gt;
&lt;p&gt;4、Prototype: 用原型实例制定创建对象的种类, 并且通过拷贝这个原型来创建的对象.&lt;/p&gt;
&lt;p&gt;5、Singleton: 保证一个类仅有一个实例，并且提供一个访问它的全局访问点。&lt;/p&gt;
&lt;h3&gt;结构型&lt;/h3&gt;
&lt;p&gt;1、Adapter(类模式): 通过类继承, 将一个类的接口转换成客户希望的另外一个接口. 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.&lt;/p&gt;
&lt;p&gt;2、Adapter: 通过对象组合, 将一个类的接口转换成客户希望的另外一个接口. 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.&lt;/p&gt;
&lt;p&gt;3、Bridge: 将抽象部分与它的显示部分分离, 使它们都可以独立地变化.&lt;/p&gt;
&lt;p&gt;4、Composite: 将对象组合成树形结构以表示“部分-整体”的层次结构. 使得客户对单个对象和复合对象的使用具有一致性.&lt;/p&gt;
&lt;p&gt;5、Decorator: 动态地给一个对象添加一些额外的职责. 就扩展功能而言, Decorator模式比生成子类方式更为灵活.&lt;/p&gt;
&lt;p&gt;6、&lt;a href="http://en.wikipedia.org/wiki/Facade_pattern"&gt;Facade&lt;/a&gt;: 为子系统中的一组接口提供一个一致的界面, Facade模式定义了一个高层的接口, 这个接口使得这一子系统更加容易使用.&lt;/p&gt;
&lt;p&gt;7、Flyweight: 运用共享技术有效地支持大量细粒度的对象.&lt;/p&gt;
&lt;p&gt;8、Proxy: 为其他对象提供一个代理以控制对这个对象的访问.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://en.wikipedia.org/wiki/Behavioral_pattern"&gt;行为型&lt;/a&gt;:&lt;/h3&gt;
&lt;p&gt;1、Interpreter(类模式): 给定一个语言，定义它的语法的一种表示, 并定义一个解释器, 该解释器使用该表示来解释语言中的语句.&lt;/p&gt;
&lt;p&gt;2、Template Method(类模式): 定义一个操作中的算法的骨架, 而将一些步骤延迟到子类中. 使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤.&lt;/p&gt;
&lt;p&gt;3、&lt;a href="http://en.wikipedia.org/wiki/Chain_of_responsibility_pattern"&gt;Chain Of Responsibility&lt;/a&gt;: 为清除请求的发送者和接受者之间的耦合, 而使多个对象都有机会处理这个请求. 将这些对象连成一条链, 并沿着这条链传递该请求, 直到有一个对象处理它.&lt;/p&gt;
&lt;p&gt;4、Command: 将一个请求封装为一个对象，从而使得可以用不同请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。&lt;/p&gt;
&lt;p&gt;5、Iterator: 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不需要暴露该对象的内部表示.&lt;/p&gt;
&lt;p&gt;6、Mediator: 用一个中介对象来封装一系列的对象交互, 中介者使得各对象不需要显式地相互引用，从而使得耦合度降低，而且可以独立地改变它们之间的交互。&lt;/p&gt;
&lt;p&gt;7、Memento: 在不破坏封装性的前提下, 捕获一个对象内部的状态, 并在该对象之外保存这个状态. 这样以后就可以将该对象恢复到保存状态.&lt;/p&gt;
&lt;p&gt;8、&lt;a href="http://en.wikipedia.org/wiki/Observer_pattern"&gt;Observer&lt;/a&gt;: 定义对象的一种一对多的依赖关系, 以便当一个对象的状态发生改变时, 所有依赖于它的对象多得到通知并自动刷新.&lt;/p&gt;
&lt;p&gt;9、State: 允许一个对象在其内部状态改变时改变它的行为.对象看起来似乎修改了它所属的类.&lt;/p&gt;
&lt;p&gt;10、&lt;a href="http://en.wikipedia.org/wiki/Strategy_pattern"&gt;Strategy&lt;/a&gt;: 定义一系列的算法把它们一个个封装起来, 并且使它们可以相互替换. 本模式使得算法的变化可以独立于使用它的客户.&lt;/p&gt;
&lt;p&gt;11、Visitor: 表示一个作用于某对象结构中的各元素的操作, 它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Software_design_pattern"&gt;维基&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns"&gt;Examples of GoF Design Patterns&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Zoey Young</dc:creator><pubDate>Mon, 09 Sep 2013 00:00:00 +0800</pubDate><guid>tag:zoeyyoung.github.io,2013-09-09:design-patten-book.html</guid><category>设计模式</category><category>书籍</category><category>笔记</category></item></channel></rss>